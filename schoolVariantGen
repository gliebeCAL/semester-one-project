#include <iostream>
#include <SFML/Graphics.hpp>
#include <stdlib.h>
#include <time.h>

using namespace std;

int main()
{
    int rooms = 4;
    int maxTunnels = 100;


    int maxX = 800;
    int maxY = 600;
    int minX = 0;
    int minY = 0;
    //This is just the max for the level-area.


    int roomMax = 20;
    int roomMin = 5;
    int tunnelSizeMin = 10;
    int tunnelSizeMax = 30;
    //Sets caps for the room and tunnel sizes (Widths for tunnel, size for rooms)

    int wallLengthX,wallLengthY;
    //wallLengths are to mod width/height of the rooms.

    wallLengthX = (roomMin) * 10;
    wallLengthY = (roomMin) * 10;
    //This would normally random-grab a number between min and max, but this is proof of concept, so nothing that fancy
    //yet.

    bool corner1 = false;
    bool corner2 = false;
    bool corner3 = false;
    bool corner4 = false;

    sf::Vertex roomCount[500];
    float pointX, pointY;
    int roomTotal;
    //Used to make the rooms.

    srand (time(NULL));
    //Sets the random

    pointX = rand() % (maxX + 1);
    pointY = rand() % (maxY + 1);

    int roomPoints = rooms * 4;

    //Some of these variables are adjustable to help create a random-er room.

    int firstRoomDir;
    int secondRoomDir;
    bool tunnelOccupied[15];
    //15 because 4 rooms

    int tunnelDirSet[5];
    //0-Up 1-Right 2-Down 3-Left
    int tunDir;
    //0 for Left/Up, 1 for Right/Down. I MISSPELLED TURN SO IT'S TUN NOW.
    bool goR,goL,goU,goD;
    //Sets which direction the tunnel goes.
    bool firstTun = false;
    sf::Vertex tunnelCount[500];

    int currTunPos = 0;
    int tunPrevDir;

    //For standard tunnel making.



    pointX = rand() % maxX + 1;
    pointY = rand() % maxY + 1;
    //places the first point anywhere

    sf::RenderWindow window(sf::VideoMode(800, 600), "SFML works!");

    //Generates the path of rooms from start to finish.

    for (int r=0;r<roomPoints;r++)
    {
        //These 4 make the corner for each square.
        if (corner1 == false)
        {
            corner1 = true;

            roomCount[r] = sf::Vector2f(pointX,pointY);

        }
        else if (corner2 == false)
        {
            corner2 = true;

            roomCount[r] = sf::Vector2f(pointX + wallLengthX,pointY);

        }
        else if (corner3 == false)
        {
            corner3 = true;

            roomCount[r] = sf::Vector2f(pointX + wallLengthX,pointY + wallLengthY);

        }
        else if (corner4 == false)
        {
            corner4 = true;

            roomCount[r] = sf::Vector2f(pointX,pointY + wallLengthY);

        }

        if (corner1 == true and corner2 == true and corner3 == true and corner4 == true)
        {
            corner1 = false;
            corner2 = false;
            corner3 = false;
            corner4 = false;

            pointX = (roomMin) * 10;
            pointY = (roomMin) * 10;

            pointX = rand() % (maxX + 1);
            pointY = rand() % (maxY + 1);

            //Resets for more rooms
        }
        //Has no collision testing.
        roomTotal = r;
    }

    //Now for tunnels

    //Hm. Procedurally generated tunnels are harder then I thought, because you have to count for all sides.
    for (int t=0;t<roomTotal;t+=4)
    {
        firstRoomDir = rand() % 4 + t;
        secondRoomDir = rand() % 4 + t + 4;


        //Checks if the spot is occupied.
        if (tunnelOccupied[firstRoomDir] == true)
        {
            while (tunnelOccupied[firstRoomDir] == true)
            {
                firstRoomDir = rand() % 4 + t;
            }
        }
        else
        {
            tunnelOccupied[firstRoomDir] = true;
        }


        //Checks if the spot is occupied.
        if (tunnelOccupied[secondRoomDir] == true)
        {
            while (tunnelOccupied[secondRoomDir] == true)
            {
                secondRoomDir = rand() % 4 + t + 4;
            }
        }
        else
        {
            tunnelOccupied[secondRoomDir] = true;
        }

        //Determines the path the tunnel will take.
        tunnelDirSet[0] = firstRoomDir % 4;
        tunDir = rand() % 2;
        //0-1


        if (roomCount[firstRoomDir].position.x < roomCount[secondRoomDir].position.x)
        {
            goL = false;
            goR = true;

        }
        else if (roomCount[firstRoomDir].position.x > roomCount[secondRoomDir].position.x)
        {
            goL = true;
            goR = false;

        }
        else if (roomCount[firstRoomDir].position.x == roomCount[secondRoomDir].position.x)
        {
            goR = false;
            goL = false;
        }

        if (roomCount[firstRoomDir].position.y < roomCount[secondRoomDir].position.y)
        {
            goU = false;
            goD = true;
        }
        else if (roomCount[firstRoomDir].position.y > roomCount[secondRoomDir].position.y)
        {
            goU = true;
            goD = false;
        }
        else if (roomCount[firstRoomDir].position.y == roomCount[secondRoomDir].position.y)
        {
            goU = false;
            goD = false;
        }



        for(int p = 0;p<21;p++)
        {
            if (firstTun == false)
            {
                if (tunnelDirSet[0] == 0)
                {
                    tunPrevDir = 0;

                    pointX = rand() % (roomCount[firstRoomDir+1].position.x - roomCount[firstRoomDir].position.x) + roomCount[firstRoomDir].position.x;
                    //This should have a random distance between firstROomDir and firstRoomDir + 1
                    //Also, should be based on 10's/other value.
                    pointY = roomCount[firstRoomDir].position.y;

                    if (pointX > (roomCount[firstRoomDir+1].position.x - 10))
                    {
                        pointX = (roomCount[firstRoomDir+1].position.x - 10);
                        //Sets the maximum the X can be.
                    }

                    tunnelCount[p] = sf::Vector2f(pointX,pointY);
                    tunnelCount[p+1] = sf::Vector2f(pointX + tunnelSizeMin,pointY);
                    //Settles the two points that don't need an if.

                    if (goU == true)
                    {
                        if (firstRoomDir % 4 == 0 or firstRoomDir % 4 == 1)
                        {
                            tunnelCount[p+2] = sf::Vector2f(pointX + tunnelSizeMin,roomCount[firstRoomDir].position.y - 30);
                            tunnelCount[p+3] = sf::Vector2f(pointX,roomCount[firstRoomDir].position.y - 30);
                        }
                        else if (firstRoomDir % 4 == 2 or firstRoomDir % 4 == 3)
                        {
                            tunnelCount[p+2] = sf::Vector2f(pointX + tunnelSizeMin,roomCount[firstRoomDir].position.y + 30);
                            tunnelCount[p+3] = sf::Vector2f(pointX,roomCount[firstRoomDir].position.y + 30);
                        }
                        // 30 is a random value. It would normally be a random number so long as it exceeds 30. Probably a multiple of 10/whatever,
                        // though.
                    }
                    else
                    {
                        tunnelCount[p+2] = sf::Vector2f(pointX + tunnelSizeMin,pointY - 30);
                        tunnelCount[p+3] = sf::Vector2f(pointX,pointY - 30);
                    }


                    //last two Y's need to be adjusted.


                }
                else if (tunnelDirSet[0] == 1)
                {
                    tunPrevDir = 1;

                    pointX = roomCount[firstRoomDir].position.x;
                    pointY = roomCount[firstRoomDir].position.y;

                    tunnelCount[p] = sf::Vector2f(pointX,pointY);
                    tunnelCount[p+1] = ;
                    tunnelCount[p+2] = ;
                    tunnelCount[p+3] = ;

                }
                else if (tunnelDirSet[0] == 2)
                {
                    tunPrevDir = 2;

                    pointX = ;
                    pointY = ;

                    tunnelCount[p] = sf::Vector2f(pointX,pointY);
                    tunnelCount[p+1] = ;
                    tunnelCount[p+2] = ;
                    tunnelCount[p+3] = ;

                }
                else if (tunnelDirSet[0] == 3)
                {
                    tunPrevDir = 3;

                    pointX = ;
                    pointY = ;

                    tunnelCount[p] = sf::Vector2f(pointX,pointY);
                    tunnelCount[p+1] = ;
                    tunnelCount[p+2] = ;
                    tunnelCount[p+3] = ;

                }

                p += 4;
            }

                firstTun = true;

                if (tunPrevDir == 0)
                {
                    if (goL == true)
                    {
                        tunPrevDir = 3;
                        goL = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else if (goR == true)
                    {
                        tunPrevDir = 1;
                        goR = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else
                    {
                        //If neither is true...
                    }

                }
                else if (tunPrevDir == 1)
                {
                    if (goU == true)
                    {
                        tunPrevDir = 0;
                        goU = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else if (goD == true)
                    {
                        tunPrevDir = 2;
                        goD = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else
                    {
                        //If neither is true...
                    }

                }
                else if (tunPrevDir == 2)
                {
                    if (goL == true)
                    {
                        tunPrevDir = 3;
                        goL = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else if (goR == true)
                    {
                        tunPrevDir = 1;
                        goR = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else
                    {
                        //If neither is true...
                    }

                }
                else if (tunPrevDir == 3)
                {
                    if (goU == true)
                    {
                        tunPrevDir = 0;
                        goU = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else if (goD == true)
                    {
                        tunPrevDir = 2;
                        goD = false;

                        pointX = ;
                        pointY = ;

                        tunnelCount[p] = sf::Vector2f(pointX,pointY);
                        tunnelCount[p+1] = ;
                        tunnelCount[p+2] = ;
                        tunnelCount[p+3] = ;

                    }
                    else
                    {
                        //If neither is true...
                    }

                }

                if ()
                {
                    //Wait. Do I even need an if statement for this? I don't think I do.
                    //Oh, wait, no, it's for if it's here to there, etc.
                    //This one will check after the movements and dictate the directions.
                }
            }
            firstTun = false;
        }

    }

    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
            {
                window.close();
            }

        }
        window.clear(sf::Color::Black);
        //Found the problem! I was writing it and then clearing it immediately.

        window.draw(roomCount,roomPoints,sf::Quads);

        window.display();
    }
}
